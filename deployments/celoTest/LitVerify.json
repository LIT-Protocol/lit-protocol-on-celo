{
  "address": "0x7d08af9a703f897c6cae78b21ae1c634750ccc59",
  "abi": [
    {
      "inputs": [],
      "name": "PubKey",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PubKeyNegate",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "headerJson",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "payloadJson",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_msg",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_sig",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xba336baee127feab4404543b416c81819045d97574ae97fea962500714c8b77f",
  "receipt": {
    "to": null,
    "from": "0x4c4a22687521c86ff8375bd045513d4fdf264ad8",
    "contractAddress": "0x7d08af9a703f897c6cae78b21ae1c634750ccc59",
    "transactionIndex": "0x2",
    "gasUsed": "0x265f94",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x42a1b1d66641b308bad35518522cce4bac9d8517f10fc657a79abb3377f9fa9b",
    "transactionHash": "0xba336baee127feab4404543b416c81819045d97574ae97fea962500714c8b77f",
    "logs": [],
    "blockNumber": "0x869107",
    "cumulativeGasUsed": "0x2b6f36",
    "status": "0x1"
  },
  "args": [],
  "solcInputHash": "44175d0413ce096832e9c67fb77a22f5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"PubKey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PubKeyNegate\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"headerJson\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"payloadJson\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LitVerify.sol\":\"LitVerify\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Base64.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n\\n    bytes constant private base64stdchars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n    bytes constant private base64urlchars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\\\";\\n\\n    function encode(string memory _str) internal pure returns (string memory) {\\n\\n        bytes memory _bs = bytes(_str);\\n        uint256 rem = _bs.length % 3;\\n\\n        uint256 res_length = (_bs.length + 2) / 3 * 4 - ((3 - rem) % 3);\\n        bytes memory res = new bytes(res_length);\\n\\n        uint256 i = 0;\\n        uint256 j = 0;\\n\\n        for (; i + 3 <= _bs.length; i += 3) {\\n            (res[j], res[j+1], res[j+2], res[j+3]) = encode3(\\n                uint8(_bs[i]),\\n                uint8(_bs[i+1]),\\n                uint8(_bs[i+2])\\n            );\\n\\n            j += 4;\\n        }\\n\\n        if (rem != 0) {\\n            uint8 la0 = uint8(_bs[_bs.length - rem]);\\n            uint8 la1 = 0;\\n\\n            if (rem == 2) {\\n                la1 = uint8(_bs[_bs.length - 1]);\\n            }\\n\\n            (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3) = encode3(la0, la1, 0);\\n            res[j] = b0;\\n            res[j+1] = b1;\\n            if (rem == 2) {\\n              res[j+2] = b2;\\n            }\\n        }\\n\\n        return string(res);\\n    }\\n\\n    function encode3(uint256 a0, uint256 a1, uint256 a2)\\n        private\\n        pure\\n        returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)\\n    {\\n\\n        uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n        uint256 c0 = (n >> 18) & 63;\\n        uint256 c1 = (n >> 12) & 63;\\n        uint256 c2 = (n >>  6) & 63;\\n        uint256 c3 = (n      ) & 63;\\n\\n        b0 = base64urlchars[c0];\\n        b1 = base64urlchars[c1];\\n        b2 = base64urlchars[c2];\\n        b3 = base64urlchars[c3];\\n    }\\n\\n}\",\"keccak256\":\"0x5ca67c6a7ac8122aff81b456f63beb36e01ddbaca6c9d05b1f70320808291c22\"},\"contracts/LitVerify.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport './Base64.sol';\\nimport './Strings.sol';\\n\\n// refer to https://github.com/paulmillr/noble-bls12-381\\ncontract LitVerify {\\n  using Base64 for string;\\n  using StringUtils for *;\\n\\n  address internal constant G1ADD = address(0xf2);\\n  address internal constant G1MUL = address(0xf1);\\n  address internal constant G1MULTIEXP = address(0xf0);\\n  address internal constant G2ADD = address(0xef);\\n  address internal constant G2MUL = address(0xee);\\n  address internal constant G2MULTIEXP = address(0xed);\\n  address internal constant PAIRING = address(0xec);\\n  address internal constant MAP_FP_TO_G1 = address(0xeb);\\n  address internal constant MAP_FP2_TO_G2 = address(0xea);\\n\\n  // constants along with precompiles\\n  bytes internal constant P =\\n    '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x1a\\\\x01\\\\x11\\\\xea\\\\x39\\\\x7f\\\\xe6\\\\x9a\\\\x4b\\\\x1b\\\\xa7\\\\xb6\\\\x43\\\\x4b\\\\xac\\\\xd7\\\\x64\\\\x77\\\\x4b\\\\x84\\\\xf3\\\\x85\\\\x12\\\\xbf\\\\x67\\\\x30\\\\xd2\\\\xa0\\\\xf6\\\\xb0\\\\xf6\\\\x24\\\\x1e\\\\xab\\\\xff\\\\xfe\\\\xb1\\\\x53\\\\xff\\\\xff\\\\xb9\\\\xfe\\\\xff\\\\xff\\\\xff\\\\xff\\\\xaa\\\\xab';\\n  bytes internal constant G1Base =\\n    '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x17\\\\xf1\\\\xd3\\\\xa7\\\\x31\\\\x97\\\\xd7\\\\x94\\\\x26\\\\x95\\\\x63\\\\x8c\\\\x4f\\\\xa9\\\\xac\\\\x0f\\\\xc3\\\\x68\\\\x8c\\\\x4f\\\\x97\\\\x74\\\\xb9\\\\x05\\\\xa1\\\\x4e\\\\x3a\\\\x3f\\\\x17\\\\x1b\\\\xac\\\\x58\\\\x6c\\\\x55\\\\xe8\\\\x3f\\\\xf9\\\\x7a\\\\x1a\\\\xef\\\\xfb\\\\x3a\\\\xf0\\\\x0a\\\\xdb\\\\x22\\\\xc6\\\\xbb\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x08\\\\xb3\\\\xf4\\\\x81\\\\xe3\\\\xaa\\\\xa0\\\\xf1\\\\xa0\\\\x9e\\\\x30\\\\xed\\\\x74\\\\x1d\\\\x8a\\\\xe4\\\\xfc\\\\xf5\\\\xe0\\\\x95\\\\xd5\\\\xd0\\\\x0a\\\\xf6\\\\x00\\\\xdb\\\\x18\\\\xcb\\\\x2c\\\\x04\\\\xb3\\\\xed\\\\xd0\\\\x3c\\\\xc7\\\\x44\\\\xa2\\\\x88\\\\x8a\\\\xe4\\\\x0c\\\\xaa\\\\x23\\\\x29\\\\x46\\\\xc5\\\\xe7\\\\xe1';\\n\\n  // won't use it directly, leave it here for debug & verify\\n  bytes public constant PubKey =\\n    '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19\\\\x71\\\\xe8\\\\x35\\\\xa1\\\\xfe\\\\x1a\\\\x4d\\\\x78\\\\xe3\\\\x81\\\\xee\\\\xbb\\\\xe0\\\\xdd\\\\xc8\\\\x4f\\\\xde\\\\x51\\\\x19\\\\x16\\\\x9d\\\\xb8\\\\x16\\\\x90\\\\x0d\\\\xe7\\\\x96\\\\xd1\\\\x01\\\\x87\\\\xf3\\\\xc5\\\\x3d\\\\x65\\\\xc1\\\\x20\\\\x2a\\\\xc0\\\\x83\\\\xd0\\\\x99\\\\xa5\\\\x17\\\\xf3\\\\x4a\\\\x9b\\\\x62\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x03\\\\xc5\\\\x8f\\\\x23\\\\x03\\\\x1b\\\\xce\\\\x4d\\\\x49\\\\xa0\\\\xe7\\\\x74\\\\xc5\\\\x68\\\\x46\\\\x75\\\\xf7\\\\x7d\\\\x81\\\\xa0\\\\x16\\\\x90\\\\x00\\\\xc6\\\\x0c\\\\x5c\\\\x5a\\\\x46\\\\xe9\\\\x68\\\\xd1\\\\xfa\\\\xec\\\\x79\\\\x3e\\\\xfa\\\\xf1\\\\xfa\\\\x6a\\\\xc4\\\\xc4\\\\xe1\\\\x03\\\\x7d\\\\x17\\\\xb4\\\\x30\\\\x77';\\n  // can be changed into variable if pub key is expected to change in the future\\n  bytes public constant PubKeyNegate =\\n    '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19\\\\x71\\\\xe8\\\\x35\\\\xa1\\\\xfe\\\\x1a\\\\x4d\\\\x78\\\\xe3\\\\x81\\\\xee\\\\xbb\\\\xe0\\\\xdd\\\\xc8\\\\x4f\\\\xde\\\\x51\\\\x19\\\\x16\\\\x9d\\\\xb8\\\\x16\\\\x90\\\\x0d\\\\xe7\\\\x96\\\\xd1\\\\x01\\\\x87\\\\xf3\\\\xc5\\\\x3d\\\\x65\\\\xc1\\\\x20\\\\x2a\\\\xc0\\\\x83\\\\xd0\\\\x99\\\\xa5\\\\x17\\\\xf3\\\\x4a\\\\x9b\\\\x62\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x16\\\\x3b\\\\x82\\\\xc7\\\\x36\\\\x64\\\\x18\\\\x4d\\\\x01\\\\x7a\\\\xc0\\\\x41\\\\x7d\\\\xe3\\\\x66\\\\x61\\\\x6c\\\\xf9\\\\xc9\\\\xe4\\\\xdc\\\\xf5\\\\x11\\\\xf9\\\\x5a\\\\xd4\\\\x78\\\\x5a\\\\x0d\\\\x48\\\\x24\\\\x29\\\\x32\\\\x32\\\\xc1\\\\x03\\\\xbf\\\\x59\\\\x95\\\\x3a\\\\xf5\\\\x1d\\\\xfc\\\\x82\\\\xe8\\\\x4b\\\\x7a\\\\x34';\\n\\n  // here use pub key as constant\\n  // _sig required to be provide as a G2 point (i.e. decoded into G2 Point before contract call)\\n  // _msg is base64url(header) + '.' + base64url(payload)\\n  function verify(bytes memory _msg, bytes memory _sig)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    bool success;\\n\\n    bytes memory Hm = hash_to_curve(_msg); // expected to be G2 Point\\n\\n    bytes memory result;\\n    (success, result) = PAIRING.staticcall(\\n      abi.encodePacked(PubKeyNegate, Hm, G1Base, _sig)\\n    );\\n    require(success, 'Pairing failed');\\n\\n    return result[31] == '\\\\x01';\\n  }\\n\\n  // another verify function accepts for raw input, useful for other contract\\n  function verify(\\n    string memory headerJson,\\n    string memory payloadJson,\\n    bytes memory signature\\n  ) public view returns (bool) {\\n    string memory headerBase64 = headerJson.encode();\\n    string memory payloadBase64 = payloadJson.encode();\\n    StringUtils.slice[] memory slices = new StringUtils.slice[](2);\\n    slices[0] = headerBase64.toSlice();\\n    slices[1] = payloadBase64.toSlice();\\n    string memory message = '.'.toSlice().join(slices);\\n\\n    return verify(bytes(message), signature);\\n  }\\n\\n  function hash_to_curve(bytes memory _msg)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    bytes memory u0;\\n    bytes memory u1;\\n    (u0, u1) = hash_to_field(_msg);\\n\\n    bool success;\\n    bytes memory p0;\\n    bytes memory p1;\\n    // map to curve\\n    (success, p0) = MAP_FP2_TO_G2.staticcall(abi.encodePacked(u0));\\n    require(success, 'Map u0 to G2 failed');\\n    (success, p1) = MAP_FP2_TO_G2.staticcall(abi.encodePacked(u1));\\n    require(success, 'Map u1 to G2 failed');\\n\\n    bytes memory p;\\n    // add up them\\n    (success, p) = G2ADD.staticcall(abi.encodePacked(p0, p1));\\n    require(success, 'Add up hash failed');\\n\\n    return p;\\n  }\\n\\n  // since count is constant 2, won't make it a parameter\\n  // output is 2 G2 point\\n  function hash_to_field(bytes memory _msg)\\n    internal\\n    view\\n    returns (bytes memory, bytes memory)\\n  {\\n    bytes memory expanded = expand_message_xmd(_msg);\\n\\n    bytes memory u00 = new bytes(64);\\n    bytes memory u01 = new bytes(64);\\n    bytes memory u10 = new bytes(64);\\n    bytes memory u11 = new bytes(64);\\n\\n    assembly {\\n      mstore(add(u00, 0x20), mload(add(expanded, 0x20)))\\n      mstore(add(u00, 0x40), mload(add(expanded, 0x40)))\\n      mstore(add(u01, 0x20), mload(add(expanded, 0x60)))\\n      mstore(add(u01, 0x40), mload(add(expanded, 0x80)))\\n      mstore(add(u10, 0x20), mload(add(expanded, 0xa0)))\\n      mstore(add(u10, 0x40), mload(add(expanded, 0xc0)))\\n      mstore(add(u11, 0x20), mload(add(expanded, 0xe0)))\\n      mstore(add(u11, 0x40), mload(add(expanded, 0x100)))\\n    }\\n\\n    u00 = callBigModExp(u00, P);\\n    u01 = callBigModExp(u01, P);\\n    u10 = callBigModExp(u10, P);\\n    u11 = callBigModExp(u11, P);\\n\\n    return (abi.encodePacked(u00, u01), abi.encodePacked(u10, u11));\\n  }\\n\\n  bytes internal constant DST_Prime =\\n    '\\\\x42\\\\x4c\\\\x53\\\\x5f\\\\x53\\\\x49\\\\x47\\\\x5f\\\\x42\\\\x4c\\\\x53\\\\x31\\\\x32\\\\x33\\\\x38\\\\x31\\\\x47\\\\x32\\\\x5f\\\\x58\\\\x4d\\\\x44\\\\x3a\\\\x53\\\\x48\\\\x41\\\\x2d\\\\x32\\\\x35\\\\x36\\\\x5f\\\\x53\\\\x53\\\\x57\\\\x55\\\\x5f\\\\x52\\\\x4f\\\\x5f\\\\x4e\\\\x55\\\\x4c\\\\x5f\\\\x2b';\\n  bytes internal constant Z_pad =\\n    '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00';\\n\\n  // since DST, len_in_bytes is constant, won't make it a parameter\\n  function expand_message_xmd(bytes memory _msg)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    bytes32[9] memory b;\\n\\n    bytes32 b_0 = sha256(\\n      abi.encodePacked(Z_pad, _msg, '\\\\x01\\\\x00\\\\x00', DST_Prime)\\n    );\\n    b[0] = sha256(abi.encodePacked(b_0, '\\\\x01', DST_Prime));\\n    for (uint8 i = 1; i <= 8; i++) {\\n      bytes32 xored = b[i - 1];\\n      assembly {\\n        xored := xor(b_0, xored)\\n      }\\n      b[i] = sha256(abi.encodePacked(xored, i + 1, DST_Prime));\\n    }\\n    bytes memory result = abi.encodePacked(\\n      b[0],\\n      b[1],\\n      b[2],\\n      b[3],\\n      b[4],\\n      b[5],\\n      b[6],\\n      b[7],\\n      b[8]\\n    );\\n\\n    // simple way to get a slice by writing a new length\\n    assembly {\\n      mstore(result, 256)\\n    }\\n    return result;\\n  }\\n\\n  function callBigModExp(bytes memory base, bytes memory modulus)\\n    internal\\n    view\\n    returns (bytes memory result)\\n  {\\n    result = new bytes(64);\\n    bool success;\\n\\n    // args: base 0x40, exponent 0x20, modulus 0x40, value ...\\n    // use BigModExp precompile with exp = 1\\n    (success, result) = address(0x05).staticcall(\\n      abi.encodePacked(\\n        '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x40',\\n        '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x20',\\n        '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x40',\\n        base,\\n        '\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01',\\n        modulus\\n      )\\n    );\\n    require(success, 'BigModExp failed');\\n  }\\n}\\n\",\"keccak256\":\"0x0442bceeb21cf35e7433751ed0d5c03477633e81c2a89eb3c0b73e112a340907\"},\"contracts/Strings.sol\":{\"content\":\"/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary StringUtils {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (self & bytes32(uint256(0xffffffffffffffffffffffffffffffff)) == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (self & bytes32(uint256(0xffffffffffffffff)) == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (self & bytes32(uint256(0xffffffff)) == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (self & bytes32(uint256(0xffff)) == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (self & bytes32(uint256(0xff)) == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len < self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask = 0; // 0xffff...\\n                unchecked {\\n                    mask -= 1;\\n                }\\n                if(shortest < 32) {\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                uint256 diff = (a & mask) - (b & mask);\\n                if (diff != 0)\\n                    return int(diff);\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b < 0x80) {\\n            l = 1;\\n        } else if(b < 0xE0) {\\n            l = 2;\\n        } else if(b < 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l > self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b < 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if(b < 0xE0) {\\n            ret = b & 0x1F;\\n            length = 2;\\n        } else if(b < 0xF0) {\\n            ret = b & 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b & 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length > self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i < length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) & 0xFF;\\n            if (b & 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b & 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr <= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr >= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr <= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for(uint i = 0; i < parts.length; i++)\\n            length += parts[i]._len;\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for(uint i = 0; i < parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i < parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\",\"keccak256\":\"0xc979e5867c55fea2200b2357e89f7372d63d8a871b66428404e64e239447988a\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612ced806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806308a981fe14610051578063d5bf8e5f14610081578063f0a443961461009f578063f7e83aee146100bd575b600080fd5b61006b60048036038101906100669190611d97565b6100ed565b6040516100789190612247565b60405180910390f35b61008961028e565b6040516100969190612262565b60405180910390f35b6100a76102aa565b6040516100b49190612262565b60405180910390f35b6100d760048036038101906100d29190611d2b565b6102c6565b6040516100e49190612247565b60405180910390f35b6000806100f985610470565b9050600061010685610470565b90506000600267ffffffffffffffff81111561014b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405190808252806020026020018201604052801561018457816020015b610171611be0565b8152602001906001900390816101695790505b50905061019083610a95565b816000815181106101ca577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101819052506101de82610a95565b81600181518110610218577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101819052506000610275826102676040518060400160405280600181526020017f2e00000000000000000000000000000000000000000000000000000000000000815250610a95565b610ac390919063ffffffff16565b905061028181876102c6565b9450505050509392505050565b6040518060a0016040528060808152602001612c386080913981565b6040518060a0016040528060808152602001612acc6080913981565b60008060006102d485610d45565b9050606060ec73ffffffffffffffffffffffffffffffffffffffff166040518060a0016040528060808152602001612acc60809139836040518060a0016040528060808152602001612a4c6080913988604051602001610337949392919061217d565b6040516020818303038152906040526040516103539190612142565b600060405180830381855afa9150503d806000811461038e576040519150601f19603f3d011682016040523d82523d6000602084013e610393565b606091505b508092508194505050826103dc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103d3906122c4565b60405180910390fd5b7f010000000000000000000000000000000000000000000000000000000000000081601f81518110610437577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614935050505092915050565b60606000829050600060038251610487919061280e565b90506000600382600361049a9190612677565b6104a4919061280e565b60046003600286516104b691906123ee565b6104c0919061247b565b6104ca919061261d565b6104d49190612677565b905060008167ffffffffffffffff811115610518577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561054a5781602001600182028036833780820191505090505b5090506000805b855160038361056091906123ee565b11610842576106638683815181106105a1577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff16876001856105c091906123ee565b815181106105f7577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff168860028661061691906123ee565b8151811061064d577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff16610fdc565b86858151811061069c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101876001876106ae91906123ee565b815181106106e5577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101886002886106f791906123ee565b8151811061072e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001018960038961074091906123ee565b81518110610777577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a90535050505060048161082c91906123ee565b905060038261083b91906123ee565b9150610551565b60008514610a875760008686885161085a9190612677565b81518110610891577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c9050600060028714156109035787600189516108bb9190612677565b815181106108f2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c90505b60008060008061091b8660ff168660ff166000610fdc565b93509350935093508389888151811061095d577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350828960018961099b91906123ee565b815181106109d2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060028b1415610a80578189600289610a1991906123ee565b81518110610a50577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053505b5050505050505b829650505050505050919050565b610a9d611be0565b600060208301905060405180604001604052808451815260200182815250915050919050565b6060600082511415610ae657604051806020016040528060008152509050610d3f565b600060018351610af69190612677565b8460000151610b05919061261d565b905060005b8351811015610b7857838181518110610b4c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610b6391906123ee565b91508080610b709061277f565b915050610b0a565b5060008167ffffffffffffffff811115610bbb577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015610bed5781602001600182028036833780820191505090505b509050600060208201905060005b8551811015610d3757610c9782878381518110610c41577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160200151888481518110610c86577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020026020010151600001516111a5565b858181518110610cd0577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610ce791906123ee565b915060018651610cf79190612677565b811015610d2457610d1182886020015189600001516111a5565b866000015182610d2191906123ee565b91505b8080610d2f9061277f565b915050610bfb565b508193505050505b92915050565b6060806060610d5384611224565b8092508193505050600060608060ea73ffffffffffffffffffffffffffffffffffffffff1685604051602001610d899190612142565b604051602081830303815290604052604051610da59190612142565b600060405180830381855afa9150503d8060008114610de0576040519150601f19603f3d011682016040523d82523d6000602084013e610de5565b606091505b50809350819450505082610e2e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e25906122e4565b60405180910390fd5b60ea73ffffffffffffffffffffffffffffffffffffffff1684604051602001610e579190612142565b604051602081830303815290604052604051610e739190612142565b600060405180830381855afa9150503d8060008114610eae576040519150601f19603f3d011682016040523d82523d6000602084013e610eb3565b606091505b50809250819450505082610efc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ef390612284565b60405180910390fd5b606060ef73ffffffffffffffffffffffffffffffffffffffff168383604051602001610f29929190612159565b604051602081830303815290604052604051610f459190612142565b600060405180830381855afa9150503d8060008114610f80576040519150601f19603f3d011682016040523d82523d6000602084013e610f85565b606091505b50809250819550505083610fce576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fc590612304565b60405180910390fd5b809650505050505050919050565b600080600080600085600888901b60108a901b171790506000603f601283901c1690506000603f600c84901c1690506000603f600685901c1690506000603f85169050604051806060016040528060408152602001612b4c604091398481518110611070577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9850604051806060016040528060408152602001612b4c6040913983815181106110ce577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9750604051806060016040528060408152602001612b4c60409139828151811061112c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9650604051806060016040528060408152602001612b4c60409139818151811061118a577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9550505050505093509350935093565b5b602081106111e457815183526020836111bf91906123ee565b92506020826111ce91906123ee565b91506020816111dd9190612677565b90506111a6565b600060018260206111f59190612677565b61010061120291906124ff565b61120c9190612677565b90508019835116818551168181178652505050505050565b606080600061123284611547565b90506000604067ffffffffffffffff811115611277577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156112a95781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff8111156112ef577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156113215781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff811115611367577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156113995781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff8111156113df577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156114115781602001600182028036833780820191505090505b5090506020850151602085015260408501516040850152606085015160208401526080850151604084015260a0850151602083015260c0850151604083015260e08501516020820152610100850151604082015261148784604051806060016040528060408152602001612b8c60409139611a8f565b93506114ab83604051806060016040528060408152602001612b8c60409139611a8f565b92506114cf82604051806060016040528060408152602001612b8c60409139611a8f565b91506114f381604051806060016040528060408152602001612b8c60409139611a8f565b90508383604051602001611508929190612159565b604051602081830303815290604052828260405160200161152a929190612159565b604051602081830303815290604052965096505050505050915091565b6060611551611bfa565b60006002604051806060016040528060408152602001612bf860409139856040518060600160405280602c8152602001612bcc602c913960405160200161159a939291906121bb565b6040516020818303038152906040526040516115b69190612142565b602060405180830381855afa1580156115d3573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906115f69190611d02565b90506002816040518060600160405280602c8152602001612bcc602c91396040516020016116259291906120d6565b6040516020818303038152906040526040516116419190612142565b602060405180830381855afa15801561165e573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906116819190611d02565b826000600981106116bb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020181815250506000600190505b60088160ff161161181c576000836001836116e691906126ab565b60ff1660098110611720577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200201519050808318905060028160018461173c9190612444565b6040518060600160405280602c8152602001612bcc602c913960405160200161176793929190612109565b6040516020818303038152906040526040516117839190612142565b602060405180830381855afa1580156117a0573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906117c39190611d02565b848360ff16600981106117ff577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002018181525050508080611814906127c8565b9150506116cb565b50600082600060098110611859577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015183600160098110611898577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151846002600981106118d7577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015185600360098110611916577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015186600460098110611955577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015187600560098110611994577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151886006600981106119d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015189600760098110611a12577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200201518a600860098110611a51577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151604051602001611a6e99989796959493929190612033565b60405160208183030381529060405290506101008152809350505050919050565b6060604067ffffffffffffffff811115611ad2577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015611b045781602001600182028036833780820191505090505b5090506000600573ffffffffffffffffffffffffffffffffffffffff168484604051602001611b349291906121f7565b604051602081830303815290604052604051611b509190612142565b600060405180830381855afa9150503d8060008114611b8b576040519150601f19603f3d011682016040523d82523d6000602084013e611b90565b606091505b50809350819250505080611bd9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd0906122a4565b60405180910390fd5b5092915050565b604051806040016040528060008152602001600081525090565b604051806101200160405280600990602082028036833780820191505090505090565b6000611c30611c2b84612349565b612324565b905082815260208101848484011115611c4857600080fd5b611c5384828561270c565b509392505050565b6000611c6e611c698461237a565b612324565b905082815260208101848484011115611c8657600080fd5b611c9184828561270c565b509392505050565b600081519050611ca881612a34565b92915050565b600082601f830112611cbf57600080fd5b8135611ccf848260208601611c1d565b91505092915050565b600082601f830112611ce957600080fd5b8135611cf9848260208601611c5b565b91505092915050565b600060208284031215611d1457600080fd5b6000611d2284828501611c99565b91505092915050565b60008060408385031215611d3e57600080fd5b600083013567ffffffffffffffff811115611d5857600080fd5b611d6485828601611cae565b925050602083013567ffffffffffffffff811115611d8157600080fd5b611d8d85828601611cae565b9150509250929050565b600080600060608486031215611dac57600080fd5b600084013567ffffffffffffffff811115611dc657600080fd5b611dd286828701611cd8565b935050602084013567ffffffffffffffff811115611def57600080fd5b611dfb86828701611cd8565b925050604084013567ffffffffffffffff811115611e1857600080fd5b611e2486828701611cae565b9150509250925092565b611e37816126df565b82525050565b611e4e611e49826126eb565b6127f2565b82525050565b6000611e5f826123ab565b611e6981856123b6565b9350611e7981856020860161271b565b611e82816128cc565b840191505092915050565b6000611e98826123ab565b611ea281856123c7565b9350611eb281856020860161271b565b80840191505092915050565b6000611ecb6013836123d2565b9150611ed6826128f7565b602082019050919050565b6000611eee6020836123e3565b9150611ef982612920565b602082019050919050565b6000611f116010836123d2565b9150611f1c8261292a565b602082019050919050565b6000611f346001836123e3565b9150611f3f82612953565b600182019050919050565b6000611f57600e836123d2565b9150611f628261297c565b602082019050919050565b6000611f7a6013836123d2565b9150611f85826129a5565b602082019050919050565b6000611f9d6020836123e3565b9150611fa8826129ce565b602082019050919050565b6000611fc06020836123e3565b9150611fcb826129d8565b602082019050919050565b6000611fe36012836123d2565b9150611fee826129e2565b602082019050919050565b60006120066003836123e3565b915061201182612a0b565b600382019050919050565b61202d612028826126ff565b6127fc565b82525050565b600061203f828c611e3d565b60208201915061204f828b611e3d565b60208201915061205f828a611e3d565b60208201915061206f8289611e3d565b60208201915061207f8288611e3d565b60208201915061208f8287611e3d565b60208201915061209f8286611e3d565b6020820191506120af8285611e3d565b6020820191506120bf8284611e3d565b6020820191508190509a9950505050505050505050565b60006120e28285611e3d565b6020820191506120f182611f27565b91506120fd8284611e8d565b91508190509392505050565b60006121158286611e3d565b602082019150612125828561201c565b6001820191506121358284611e8d565b9150819050949350505050565b600061214e8284611e8d565b915081905092915050565b60006121658285611e8d565b91506121718284611e8d565b91508190509392505050565b60006121898287611e8d565b91506121958286611e8d565b91506121a18285611e8d565b91506121ad8284611e8d565b915081905095945050505050565b60006121c78286611e8d565b91506121d38285611e8d565b91506121de82611ff9565b91506121ea8284611e8d565b9150819050949350505050565b600061220282611ee1565b915061220d82611fb3565b915061221882611ee1565b91506122248285611e8d565b915061222f82611f90565b915061223b8284611e8d565b91508190509392505050565b600060208201905061225c6000830184611e2e565b92915050565b6000602082019050818103600083015261227c8184611e54565b905092915050565b6000602082019050818103600083015261229d81611ebe565b9050919050565b600060208201905081810360008301526122bd81611f04565b9050919050565b600060208201905081810360008301526122dd81611f4a565b9050919050565b600060208201905081810360008301526122fd81611f6d565b9050919050565b6000602082019050818103600083015261231d81611fd6565b9050919050565b600061232e61233f565b905061233a828261274e565b919050565b6000604051905090565b600067ffffffffffffffff8211156123645761236361289d565b5b61236d826128cc565b9050602081019050919050565b600067ffffffffffffffff8211156123955761239461289d565b5b61239e826128cc565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b60006123f9826126f5565b9150612404836126f5565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156124395761243861283f565b5b828201905092915050565b600061244f826126ff565b915061245a836126ff565b92508260ff038211156124705761246f61283f565b5b828201905092915050565b6000612486826126f5565b9150612491836126f5565b9250826124a1576124a061286e565b5b828204905092915050565b6000808291508390505b60018511156124f6578086048111156124d2576124d161283f565b5b60018516156124e15780820291505b80810290506124ef856128ea565b94506124b6565b94509492505050565b600061250a826126f5565b9150612515836126f5565b92506125427fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461254a565b905092915050565b60008261255a5760019050612616565b816125685760009050612616565b816001811461257e5760028114612588576125b7565b6001915050612616565b60ff84111561259a5761259961283f565b5b8360020a9150848211156125b1576125b061283f565b5b50612616565b5060208310610133831016604e8410600b84101617156125ec5782820a9050838111156125e7576125e661283f565b5b612616565b6125f984848460016124ac565b925090508184048111156126105761260f61283f565b5b81810290505b9392505050565b6000612628826126f5565b9150612633836126f5565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561266c5761266b61283f565b5b828202905092915050565b6000612682826126f5565b915061268d836126f5565b9250828210156126a05761269f61283f565b5b828203905092915050565b60006126b6826126ff565b91506126c1836126ff565b9250828210156126d4576126d361283f565b5b828203905092915050565b60008115159050919050565b6000819050919050565b6000819050919050565b600060ff82169050919050565b82818337600083830152505050565b60005b8381101561273957808201518184015260208101905061271e565b83811115612748576000848401525b50505050565b612757826128cc565b810181811067ffffffffffffffff821117156127765761277561289d565b5b80604052505050565b600061278a826126f5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156127bd576127bc61283f565b5b600182019050919050565b60006127d3826126ff565b915060ff8214156127e7576127e661283f565b5b600182019050919050565b6000819050919050565b6000612807826128dd565b9050919050565b6000612819826126f5565b9150612824836126f5565b9250826128345761283361286e565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b60008160f81b9050919050565b60008160011c9050919050565b7f4d617020753120746f204732206661696c656400000000000000000000000000600082015250565b6040600082015250565b7f4269674d6f64457870206661696c656400000000000000000000000000000000600082015250565b7f0100000000000000000000000000000000000000000000000000000000000000600082015250565b7f50616972696e67206661696c6564000000000000000000000000000000000000600082015250565b7f4d617020753020746f204732206661696c656400000000000000000000000000600082015250565b6001600082015250565b6020600082015250565b7f4164642075702068617368206661696c65640000000000000000000000000000600082015250565b7f0100000000000000000000000000000000000000000000000000000000000000600082015250565b612a3d816126eb565b8114612a4857600080fd5b5056fe0000000000000000000000000000000017f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb0000000000000000000000000000000008b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1000000000000000000000000000000001971e835a1fe1a4d78e381eebbe0ddc84fde5119169db816900de796d10187f3c53d65c1202ac083d099a517f34a9b6200000000000000000000000000000000163b82c73664184d017ac0417de366616cf9c9e4dcf511f95ad4785a0d4824293232c103bf59953af51dfc82e84b7a344142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5f000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab424c535f5349475f424c53313233383147325f584d443a5348412d3235365f535357555f524f5f4e554c5f2b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001971e835a1fe1a4d78e381eebbe0ddc84fde5119169db816900de796d10187f3c53d65c1202ac083d099a517f34a9b620000000000000000000000000000000003c58f23031bce4d49a0e774c5684675f77d81a0169000c60c5c5a46e968d1faec793efaf1fa6ac4c4e1037d17b43077a2646970667358221220b49abe6210b5b9b0031b9eb7f17a9ff1c334ee6922f9e994a9f1416bdc9a819b64736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806308a981fe14610051578063d5bf8e5f14610081578063f0a443961461009f578063f7e83aee146100bd575b600080fd5b61006b60048036038101906100669190611d97565b6100ed565b6040516100789190612247565b60405180910390f35b61008961028e565b6040516100969190612262565b60405180910390f35b6100a76102aa565b6040516100b49190612262565b60405180910390f35b6100d760048036038101906100d29190611d2b565b6102c6565b6040516100e49190612247565b60405180910390f35b6000806100f985610470565b9050600061010685610470565b90506000600267ffffffffffffffff81111561014b577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405190808252806020026020018201604052801561018457816020015b610171611be0565b8152602001906001900390816101695790505b50905061019083610a95565b816000815181106101ca577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101819052506101de82610a95565b81600181518110610218577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101819052506000610275826102676040518060400160405280600181526020017f2e00000000000000000000000000000000000000000000000000000000000000815250610a95565b610ac390919063ffffffff16565b905061028181876102c6565b9450505050509392505050565b6040518060a0016040528060808152602001612c386080913981565b6040518060a0016040528060808152602001612acc6080913981565b60008060006102d485610d45565b9050606060ec73ffffffffffffffffffffffffffffffffffffffff166040518060a0016040528060808152602001612acc60809139836040518060a0016040528060808152602001612a4c6080913988604051602001610337949392919061217d565b6040516020818303038152906040526040516103539190612142565b600060405180830381855afa9150503d806000811461038e576040519150601f19603f3d011682016040523d82523d6000602084013e610393565b606091505b508092508194505050826103dc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103d3906122c4565b60405180910390fd5b7f010000000000000000000000000000000000000000000000000000000000000081601f81518110610437577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614935050505092915050565b60606000829050600060038251610487919061280e565b90506000600382600361049a9190612677565b6104a4919061280e565b60046003600286516104b691906123ee565b6104c0919061247b565b6104ca919061261d565b6104d49190612677565b905060008167ffffffffffffffff811115610518577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561054a5781602001600182028036833780820191505090505b5090506000805b855160038361056091906123ee565b11610842576106638683815181106105a1577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff16876001856105c091906123ee565b815181106105f7577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff168860028661061691906123ee565b8151811061064d577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c60ff16610fdc565b86858151811061069c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101876001876106ae91906123ee565b815181106106e5577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101886002886106f791906123ee565b8151811061072e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001018960038961074091906123ee565b81518110610777577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a9053847effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191660001a90535050505060048161082c91906123ee565b905060038261083b91906123ee565b9150610551565b60008514610a875760008686885161085a9190612677565b81518110610891577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c9050600060028714156109035787600189516108bb9190612677565b815181106108f2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c90505b60008060008061091b8660ff168660ff166000610fdc565b93509350935093508389888151811061095d577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350828960018961099b91906123ee565b815181106109d2577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060028b1415610a80578189600289610a1991906123ee565b81518110610a50577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053505b5050505050505b829650505050505050919050565b610a9d611be0565b600060208301905060405180604001604052808451815260200182815250915050919050565b6060600082511415610ae657604051806020016040528060008152509050610d3f565b600060018351610af69190612677565b8460000151610b05919061261d565b905060005b8351811015610b7857838181518110610b4c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610b6391906123ee565b91508080610b709061277f565b915050610b0a565b5060008167ffffffffffffffff811115610bbb577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015610bed5781602001600182028036833780820191505090505b509050600060208201905060005b8551811015610d3757610c9782878381518110610c41577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160200151888481518110610c86577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020026020010151600001516111a5565b858181518110610cd0577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610ce791906123ee565b915060018651610cf79190612677565b811015610d2457610d1182886020015189600001516111a5565b866000015182610d2191906123ee565b91505b8080610d2f9061277f565b915050610bfb565b508193505050505b92915050565b6060806060610d5384611224565b8092508193505050600060608060ea73ffffffffffffffffffffffffffffffffffffffff1685604051602001610d899190612142565b604051602081830303815290604052604051610da59190612142565b600060405180830381855afa9150503d8060008114610de0576040519150601f19603f3d011682016040523d82523d6000602084013e610de5565b606091505b50809350819450505082610e2e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e25906122e4565b60405180910390fd5b60ea73ffffffffffffffffffffffffffffffffffffffff1684604051602001610e579190612142565b604051602081830303815290604052604051610e739190612142565b600060405180830381855afa9150503d8060008114610eae576040519150601f19603f3d011682016040523d82523d6000602084013e610eb3565b606091505b50809250819450505082610efc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ef390612284565b60405180910390fd5b606060ef73ffffffffffffffffffffffffffffffffffffffff168383604051602001610f29929190612159565b604051602081830303815290604052604051610f459190612142565b600060405180830381855afa9150503d8060008114610f80576040519150601f19603f3d011682016040523d82523d6000602084013e610f85565b606091505b50809250819550505083610fce576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fc590612304565b60405180910390fd5b809650505050505050919050565b600080600080600085600888901b60108a901b171790506000603f601283901c1690506000603f600c84901c1690506000603f600685901c1690506000603f85169050604051806060016040528060408152602001612b4c604091398481518110611070577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9850604051806060016040528060408152602001612b4c6040913983815181106110ce577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9750604051806060016040528060408152602001612b4c60409139828151811061112c577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9650604051806060016040528060408152602001612b4c60409139818151811061118a577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b9550505050505093509350935093565b5b602081106111e457815183526020836111bf91906123ee565b92506020826111ce91906123ee565b91506020816111dd9190612677565b90506111a6565b600060018260206111f59190612677565b61010061120291906124ff565b61120c9190612677565b90508019835116818551168181178652505050505050565b606080600061123284611547565b90506000604067ffffffffffffffff811115611277577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156112a95781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff8111156112ef577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156113215781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff811115611367577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156113995781602001600182028036833780820191505090505b5090506000604067ffffffffffffffff8111156113df577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156114115781602001600182028036833780820191505090505b5090506020850151602085015260408501516040850152606085015160208401526080850151604084015260a0850151602083015260c0850151604083015260e08501516020820152610100850151604082015261148784604051806060016040528060408152602001612b8c60409139611a8f565b93506114ab83604051806060016040528060408152602001612b8c60409139611a8f565b92506114cf82604051806060016040528060408152602001612b8c60409139611a8f565b91506114f381604051806060016040528060408152602001612b8c60409139611a8f565b90508383604051602001611508929190612159565b604051602081830303815290604052828260405160200161152a929190612159565b604051602081830303815290604052965096505050505050915091565b6060611551611bfa565b60006002604051806060016040528060408152602001612bf860409139856040518060600160405280602c8152602001612bcc602c913960405160200161159a939291906121bb565b6040516020818303038152906040526040516115b69190612142565b602060405180830381855afa1580156115d3573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906115f69190611d02565b90506002816040518060600160405280602c8152602001612bcc602c91396040516020016116259291906120d6565b6040516020818303038152906040526040516116419190612142565b602060405180830381855afa15801561165e573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906116819190611d02565b826000600981106116bb577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020181815250506000600190505b60088160ff161161181c576000836001836116e691906126ab565b60ff1660098110611720577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200201519050808318905060028160018461173c9190612444565b6040518060600160405280602c8152602001612bcc602c913960405160200161176793929190612109565b6040516020818303038152906040526040516117839190612142565b602060405180830381855afa1580156117a0573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906117c39190611d02565b848360ff16600981106117ff577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002018181525050508080611814906127c8565b9150506116cb565b50600082600060098110611859577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015183600160098110611898577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151846002600981106118d7577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015185600360098110611916577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015186600460098110611955577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015187600560098110611994577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151886006600981106119d3577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002015189600760098110611a12577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200201518a600860098110611a51577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6020020151604051602001611a6e99989796959493929190612033565b60405160208183030381529060405290506101008152809350505050919050565b6060604067ffffffffffffffff811115611ad2577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015611b045781602001600182028036833780820191505090505b5090506000600573ffffffffffffffffffffffffffffffffffffffff168484604051602001611b349291906121f7565b604051602081830303815290604052604051611b509190612142565b600060405180830381855afa9150503d8060008114611b8b576040519150601f19603f3d011682016040523d82523d6000602084013e611b90565b606091505b50809350819250505080611bd9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd0906122a4565b60405180910390fd5b5092915050565b604051806040016040528060008152602001600081525090565b604051806101200160405280600990602082028036833780820191505090505090565b6000611c30611c2b84612349565b612324565b905082815260208101848484011115611c4857600080fd5b611c5384828561270c565b509392505050565b6000611c6e611c698461237a565b612324565b905082815260208101848484011115611c8657600080fd5b611c9184828561270c565b509392505050565b600081519050611ca881612a34565b92915050565b600082601f830112611cbf57600080fd5b8135611ccf848260208601611c1d565b91505092915050565b600082601f830112611ce957600080fd5b8135611cf9848260208601611c5b565b91505092915050565b600060208284031215611d1457600080fd5b6000611d2284828501611c99565b91505092915050565b60008060408385031215611d3e57600080fd5b600083013567ffffffffffffffff811115611d5857600080fd5b611d6485828601611cae565b925050602083013567ffffffffffffffff811115611d8157600080fd5b611d8d85828601611cae565b9150509250929050565b600080600060608486031215611dac57600080fd5b600084013567ffffffffffffffff811115611dc657600080fd5b611dd286828701611cd8565b935050602084013567ffffffffffffffff811115611def57600080fd5b611dfb86828701611cd8565b925050604084013567ffffffffffffffff811115611e1857600080fd5b611e2486828701611cae565b9150509250925092565b611e37816126df565b82525050565b611e4e611e49826126eb565b6127f2565b82525050565b6000611e5f826123ab565b611e6981856123b6565b9350611e7981856020860161271b565b611e82816128cc565b840191505092915050565b6000611e98826123ab565b611ea281856123c7565b9350611eb281856020860161271b565b80840191505092915050565b6000611ecb6013836123d2565b9150611ed6826128f7565b602082019050919050565b6000611eee6020836123e3565b9150611ef982612920565b602082019050919050565b6000611f116010836123d2565b9150611f1c8261292a565b602082019050919050565b6000611f346001836123e3565b9150611f3f82612953565b600182019050919050565b6000611f57600e836123d2565b9150611f628261297c565b602082019050919050565b6000611f7a6013836123d2565b9150611f85826129a5565b602082019050919050565b6000611f9d6020836123e3565b9150611fa8826129ce565b602082019050919050565b6000611fc06020836123e3565b9150611fcb826129d8565b602082019050919050565b6000611fe36012836123d2565b9150611fee826129e2565b602082019050919050565b60006120066003836123e3565b915061201182612a0b565b600382019050919050565b61202d612028826126ff565b6127fc565b82525050565b600061203f828c611e3d565b60208201915061204f828b611e3d565b60208201915061205f828a611e3d565b60208201915061206f8289611e3d565b60208201915061207f8288611e3d565b60208201915061208f8287611e3d565b60208201915061209f8286611e3d565b6020820191506120af8285611e3d565b6020820191506120bf8284611e3d565b6020820191508190509a9950505050505050505050565b60006120e28285611e3d565b6020820191506120f182611f27565b91506120fd8284611e8d565b91508190509392505050565b60006121158286611e3d565b602082019150612125828561201c565b6001820191506121358284611e8d565b9150819050949350505050565b600061214e8284611e8d565b915081905092915050565b60006121658285611e8d565b91506121718284611e8d565b91508190509392505050565b60006121898287611e8d565b91506121958286611e8d565b91506121a18285611e8d565b91506121ad8284611e8d565b915081905095945050505050565b60006121c78286611e8d565b91506121d38285611e8d565b91506121de82611ff9565b91506121ea8284611e8d565b9150819050949350505050565b600061220282611ee1565b915061220d82611fb3565b915061221882611ee1565b91506122248285611e8d565b915061222f82611f90565b915061223b8284611e8d565b91508190509392505050565b600060208201905061225c6000830184611e2e565b92915050565b6000602082019050818103600083015261227c8184611e54565b905092915050565b6000602082019050818103600083015261229d81611ebe565b9050919050565b600060208201905081810360008301526122bd81611f04565b9050919050565b600060208201905081810360008301526122dd81611f4a565b9050919050565b600060208201905081810360008301526122fd81611f6d565b9050919050565b6000602082019050818103600083015261231d81611fd6565b9050919050565b600061232e61233f565b905061233a828261274e565b919050565b6000604051905090565b600067ffffffffffffffff8211156123645761236361289d565b5b61236d826128cc565b9050602081019050919050565b600067ffffffffffffffff8211156123955761239461289d565b5b61239e826128cc565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b60006123f9826126f5565b9150612404836126f5565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156124395761243861283f565b5b828201905092915050565b600061244f826126ff565b915061245a836126ff565b92508260ff038211156124705761246f61283f565b5b828201905092915050565b6000612486826126f5565b9150612491836126f5565b9250826124a1576124a061286e565b5b828204905092915050565b6000808291508390505b60018511156124f6578086048111156124d2576124d161283f565b5b60018516156124e15780820291505b80810290506124ef856128ea565b94506124b6565b94509492505050565b600061250a826126f5565b9150612515836126f5565b92506125427fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461254a565b905092915050565b60008261255a5760019050612616565b816125685760009050612616565b816001811461257e5760028114612588576125b7565b6001915050612616565b60ff84111561259a5761259961283f565b5b8360020a9150848211156125b1576125b061283f565b5b50612616565b5060208310610133831016604e8410600b84101617156125ec5782820a9050838111156125e7576125e661283f565b5b612616565b6125f984848460016124ac565b925090508184048111156126105761260f61283f565b5b81810290505b9392505050565b6000612628826126f5565b9150612633836126f5565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561266c5761266b61283f565b5b828202905092915050565b6000612682826126f5565b915061268d836126f5565b9250828210156126a05761269f61283f565b5b828203905092915050565b60006126b6826126ff565b91506126c1836126ff565b9250828210156126d4576126d361283f565b5b828203905092915050565b60008115159050919050565b6000819050919050565b6000819050919050565b600060ff82169050919050565b82818337600083830152505050565b60005b8381101561273957808201518184015260208101905061271e565b83811115612748576000848401525b50505050565b612757826128cc565b810181811067ffffffffffffffff821117156127765761277561289d565b5b80604052505050565b600061278a826126f5565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156127bd576127bc61283f565b5b600182019050919050565b60006127d3826126ff565b915060ff8214156127e7576127e661283f565b5b600182019050919050565b6000819050919050565b6000612807826128dd565b9050919050565b6000612819826126f5565b9150612824836126f5565b9250826128345761283361286e565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b60008160f81b9050919050565b60008160011c9050919050565b7f4d617020753120746f204732206661696c656400000000000000000000000000600082015250565b6040600082015250565b7f4269674d6f64457870206661696c656400000000000000000000000000000000600082015250565b7f0100000000000000000000000000000000000000000000000000000000000000600082015250565b7f50616972696e67206661696c6564000000000000000000000000000000000000600082015250565b7f4d617020753020746f204732206661696c656400000000000000000000000000600082015250565b6001600082015250565b6020600082015250565b7f4164642075702068617368206661696c65640000000000000000000000000000600082015250565b7f0100000000000000000000000000000000000000000000000000000000000000600082015250565b612a3d816126eb565b8114612a4857600080fd5b5056fe0000000000000000000000000000000017f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb0000000000000000000000000000000008b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1000000000000000000000000000000001971e835a1fe1a4d78e381eebbe0ddc84fde5119169db816900de796d10187f3c53d65c1202ac083d099a517f34a9b6200000000000000000000000000000000163b82c73664184d017ac0417de366616cf9c9e4dcf511f95ad4785a0d4824293232c103bf59953af51dfc82e84b7a344142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5f000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab424c535f5349475f424c53313233383147325f584d443a5348412d3235365f535357555f524f5f4e554c5f2b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001971e835a1fe1a4d78e381eebbe0ddc84fde5119169db816900de796d10187f3c53d65c1202ac083d099a517f34a9b620000000000000000000000000000000003c58f23031bce4d49a0e774c5684675f77d81a0169000c60c5c5a46e968d1faec793efaf1fa6ac4c4e1037d17b43077a2646970667358221220b49abe6210b5b9b0031b9eb7f17a9ff1c334ee6922f9e994a9f1416bdc9a819b64736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}